[ -f /opt/boxen/env.sh ] && source /opt/boxen/env.sh

export PATH=$HOME/bin:$PATH
#
# Python
export WORKON_HOME=$HOME/.virtualenvs
source `which virtualenvwrapper.sh`

# Java
export JAVA_HOME="$(/usr/libexec/java_home)"

#SVN, GIT
export SVN_EDITOR=vim
export GIT_EDITOR=vim

# lolcommits
export LOLCOMMITS_FONT="/Library/Fonts/ヒラギノ角ゴ Std W8.otf"

## Shortcuts

alias phplint='find . -name "*.php" -exec php -l {} \; | grep "Parse error"'    
alias vi='env LANG=ja_JP.UTF-8 /Applications/MacVim.app/Contents/MacOS/Vim "$@"'
alias grep="grep --color=always"

# Attach tmux session
function ta() {
    if [ $SHLVL = 1 ]; then
          tmux attach || tmux -f ~/.tmux.conf
    fi
}

# Search by tag
function ts() {
    search_tags=($@)
    search_tags=(${search_tags/#/kMDItemUserTags ==})
    search_tags="$(IFS=,; echo "${search_tags[*]}")"
    search_tags="${search_tags//,/ && }"
    mdfind "$search_tags"
}

alias vim="/Applications/MacVim.app/Contents/MacOS/Vim"

# command "mvi"
alias mvim="/Applications/MacVim.app/Contents/MacOS/mvim"
function mvi() {
    if [ $# != 0 ]; then
        env LANG=ja_JP.UTF-8 > /dev/null
        mvim --remote-tab-silent $@
    else
        srvs=`mvim --serverlist 2> /dev/null`
        if [ "$srvs" != "" ]; then
            env LANG=ja_JP.UTF-8 > /dev/null
            mvim --remote-send ":tabnew<CR>"
        else
            env LANG=ja_JP.UTF-8 > /dev/null
            mvim
        fi
    fi
}

# ci
function jenkins() {
    if [ -n "$1" ] && [ -n "$2" ]; then
        if [ -n "$3" ]; then
            JENKINS_URL="http://jenkins.ci.dev/job/$1/buildWithParameters?token=$2&branch=$3"
        else
            JENKINS_URL="http://jenkins.ci.dev/job/$1/build?token=$2"
        fi
        echo $JENKINS_URL
        curl $JENKINS_URL
    else
        echo "jenkins [project_id] [token] [branch]"
        echo "http://jenkins_host/job/[project_id]/buildWithParameters?token=[token]&branch=[branch]"
    fi
}

# Completion


# Git cd to current git root
function gu() {
    cd ./$(git rev-parse --show-cdup)
    if [ $# = 1 ]; then
        cd $1
    fi
}

## Default shell configuration
#
set prompt
autoload colors
colors

function rprompt-git-current-branch {
    local name st color

    if [[ "$PWD" =~ '/\.git(/.*)?$' ]]; then
        return
    fi
    name=$(basename "`git symbolic-ref HEAD 2> /dev/null`")
    if [[ -z $name ]]; then
        return
    fi
    st=`git status 2> /dev/null`
    if [[ -n `echo "$st" | grep "^nothing to"` ]]; then
        color=${fg[green]}
    elif [[ -n `echo "$st" | grep "^nothing added"` ]]; then
        color=${fg[yellow]}
    elif [[ -n `echo "$st" | grep "^# Untracked"` ]]; then
        color=${fg_bold[red]}
    else
        color=${fg[red]}
    fi

    # %{...%} は囲まれた文字列がエスケープシーケンスであることを明示する
    # これをしないと右プロンプトの位置がずれる
    echo "%{$color%}$name%{$reset_color%} "
}

PROMPT="[%n@%m] %(!.#.$) "
PROMPT2="%{${fg[red]}%}%_> %{${reset_color}%}"
SPROMPT="correct: %R -> %r [nyae]? "
#RPROMPT="%{${fg[red]}%}[%~]%{${reset_color}%}"
RPROMPT='[`rprompt-git-current-branch`%~]'

setopt prompt_subst

# auto change directory
#
setopt auto_cd

# auto directory pushd that you can get dirs list by cd -[tab]
#
setopt auto_pushd

# command correct edition before each completion attempt
#
setopt correct

# compacked complete list display
#
setopt list_packed

# no remove postfix slash of command line
#
setopt noautoremoveslash

# no beep sound when complete list displayed
#
setopt nolistbeep


### Keybind configuration
##
## emacs like keybind (e.x. Ctrl-a goes to head of a line and Ctrl-e goes 
##   to end of it)
##
#bindkey -e
#
## historical backward/forward search with linehead string binded to ^P/^N
##
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^p" history-beginning-search-backward-end
bindkey "^n" history-beginning-search-forward-end
#bindkey "¥¥ep" history-beginning-search-backward-end
#bindkey "¥¥en" history-beginning-search-forward-end


## Command history configuration
#
HISTFILE=$HOME/.zsh_history
HISTSIZE=1000
SAVEHIST=100000
setopt hist_ignore_dups     # ignore duplication command history list
setopt share_history        # share command history data

#
## Completion configuration
#
fpath=(‾/.zsh/functions/Completion ${fpath})
autoload -U compinit
compinit


### zsh editor
##
#autoload zed
#
#
# Prediction configuration

#autoload predict-on
#predict-on


## Alias configuration
#
# expand aliases before completing
#
setopt complete_aliases     # aliased ls needs if file/dir completions work

case "${OSTYPE}" in
freebsd*|darwin*)
    alias ls="ls -G -w"
    ;;
linux*)
    alias ls="ls --color"
    ;;
esac

alias la="ls -a"

## terminal configuration
unset LSCOLORS
case "${TERM}" in
xterm)
    export TERM=xterm-color
    ;;
kterm)
    export TERM=kterm-color
    # set BackSpace control character
    stty erase
    ;;
cons25)
    unset LANG
    export LSCOLORS=ExFxCxdxBxegedabagacad
    export LS_COLORS='di=01;34:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
    zstyle ':completion:*' list-colors ¥
        'di=;34;1' 'ln=;35;1' 'so=;32;1' 'ex=31;1' 'bd=46;34' 'cd=43;34'
    ;;
esac


# GIT completion
[ -f $HOME/.git-completion.sh ] && source $HOME/.git-completion.sh

# ZSH Plugins

# j
[[ -s `brew --prefix`/etc/autojump.sh ]] && . `brew --prefix`/etc/autojump.sh

# Load Local Setting
[ -f $HOME/.zshrc.local ] && source $HOME/.zshrc.local

# Load Execution Setting
[ -f $HOME/.zshrc.exec ] && source $HOME/.zshrc.exec
